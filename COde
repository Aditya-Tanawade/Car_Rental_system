-- Notification Table for Real-time Updates
CREATE TABLE NOTIFICATIONS (
    NOTIFICATION_ID NUMBER PRIMARY KEY,
    RECIPIENT_ID VARCHAR2(40) NOT NULL,  -- Employee_ID/Candidate_ID who receives notification
    RECIPIENT_TYPE VARCHAR2(20) NOT NULL, -- 'PM', 'TL', 'HR', 'CANDIDATE'
    SENDER_ID VARCHAR2(40),  -- Who triggered the action
    SENDER_TYPE VARCHAR2(20), -- 'PM', 'TL', 'HR', 'CANDIDATE', 'SYSTEM'
    
    NOTIFICATION_TYPE VARCHAR2(50) NOT NULL, -- Type of notification
    TITLE VARCHAR2(200) NOT NULL,
    MESSAGE VARCHAR2(1000) NOT NULL,
    
    -- Reference IDs for related entities
    JOB_REQUEST_ID NUMBER,
    PROJECT_ID NUMBER,
    APPLICATION_ID NUMBER,
    INTERVIEW_ID NUMBER,
    CANDIDATE_ID NUMBER,
    
    -- Action URL for navigation
    ACTION_URL VARCHAR2(500),
    
    -- Status tracking
    IS_READ NUMBER(1) DEFAULT 0, -- 0 = Unread, 1 = Read
    READ_AT DATE,
    
    PRIORITY VARCHAR2(10) DEFAULT 'MEDIUM', -- 'HIGH', 'MEDIUM', 'LOW'
    
    CREATED_AT DATE DEFAULT SYSDATE,
    EXPIRES_AT DATE, -- Optional: for auto-cleanup of old notifications
    
    -- Foreign key constraints
    CONSTRAINT fk_notif_job_request FOREIGN KEY (JOB_REQUEST_ID) REFERENCES JOB_REQUESTS(JOB_REQUEST_ID),
    CONSTRAINT fk_notif_project FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID),
    CONSTRAINT fk_notif_application FOREIGN KEY (APPLICATION_ID) REFERENCES CANDIDATE_APPLICATIONS(APPLICATION_ID),
    CONSTRAINT fk_notif_interview FOREIGN KEY (INTERVIEW_ID) REFERENCES INTERVIEWS(INTERVIEW_ID),
    CONSTRAINT fk_notif_candidate FOREIGN KEY (CANDIDATE_ID) REFERENCES CANDIDATES(CANDIDATE_ID),
    
    CONSTRAINT chk_is_read CHECK (IS_READ IN (0, 1)),
    CONSTRAINT chk_recipient_type CHECK (RECIPIENT_TYPE IN ('PM', 'TL', 'HR', 'CANDIDATE')),
    CONSTRAINT chk_priority CHECK (PRIORITY IN ('HIGH', 'MEDIUM', 'LOW'))
);

-- Sequence for notification ID
CREATE SEQUENCE NOTIFICATION_SEQ START WITH 1 INCREMENT BY 1;

-- Indexes for performance
CREATE INDEX idx_notif_recipient ON NOTIFICATIONS(RECIPIENT_ID, IS_READ, CREATED_AT DESC);
CREATE INDEX idx_notif_type ON NOTIFICATIONS(NOTIFICATION_TYPE);
CREATE INDEX idx_notif_job_request ON NOTIFICATIONS(JOB_REQUEST_ID);
CREATE INDEX idx_notif_created_at ON NOTIFICATIONS(CREATED_AT DESC);

-- Notification Types Reference Table (Optional but recommended)
CREATE TABLE NOTIFICATION_TYPES (
    TYPE_CODE VARCHAR2(50) PRIMARY KEY,
    TYPE_NAME VARCHAR2(100) NOT NULL,
    DESCRIPTION VARCHAR2(500),
    DEFAULT_PRIORITY VARCHAR2(10) DEFAULT 'MEDIUM',
    ACTIVE NUMBER(1) DEFAULT 1
);

-- Insert standard notification types
INSERT INTO NOTIFICATION_TYPES VALUES ('JOB_REQUEST_CREATED', 'Job Request Created', 'Team Lead created a new job request', 'MEDIUM', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('JOB_REQUEST_APPROVED', 'Job Request Approved', 'Project Manager approved job request', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('JOB_REQUEST_DECLINED', 'Job Request Declined', 'Project Manager declined job request', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('JOB_REQUEST_FORWARDED', 'Job Request Forwarded to HR', 'Project Manager forwarded job request to HR', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('JOB_POSTED', 'Job Posted on Portal', 'HR posted job on portal', 'MEDIUM', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('NEW_APPLICATION', 'New Candidate Application', 'Candidate applied for job', 'MEDIUM', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('APPLICATION_SHORTLISTED', 'Application Shortlisted', 'Your application has been shortlisted', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('APPLICATION_REJECTED', 'Application Rejected', 'Your application has been rejected', 'MEDIUM', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('INTERVIEW_SCHEDULED', 'Interview Scheduled', 'Interview has been scheduled', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('INTERVIEW_RESCHEDULED', 'Interview Rescheduled', 'Interview date/time changed', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('INTERVIEW_CANCELLED', 'Interview Cancelled', 'Interview has been cancelled', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('INTERVIEW_REMINDER', 'Interview Reminder', 'Upcoming interview reminder', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('OFFER_LETTER_SENT', 'Offer Letter Sent', 'Offer letter has been sent', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('PROJECT_ASSIGNED', 'Project Assigned', 'You have been assigned to a project', 'HIGH', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('PROJECT_CREATED', 'New Project Created', 'New project has been created', 'MEDIUM', 1);
INSERT INTO NOTIFICATION_TYPES VALUES ('EMPLOYEE_ASSIGNED', 'Employee Assigned to Project', 'Employee assigned from bench to project', 'MEDIUM', 1);

COMMIT;










package com.finalproject.hrportal.service;

import com.finalproject.hrportal.dto.NotificationDTO;
import java.util.List;

public interface NotificationService {
    
    // Create notifications
    void createNotification(NotificationDTO notificationDTO);
    void createJobRequestNotification(int jobRequestId, String type, String recipientId);
    void createApplicationNotification(int applicationId, String type, String recipientId);
    void createInterviewNotification(int interviewId, String type, List<String> recipientIds);
    void createProjectAssignmentNotification(int projectId, String employeeId);
    
    // Retrieve notifications
    List<NotificationDTO> getUnreadNotifications(String recipientId);
    List<NotificationDTO> getAllNotifications(String recipientId, int page, int size);
    Integer getUnreadCount(String recipientId);
    
    // Update notifications
    boolean markAsRead(int notificationId);
    boolean markAllAsRead(String recipientId);
    boolean deleteNotification(int notificationId);
    
    // Cleanup
    void cleanupExpiredNotifications();
}


// DTO
package com.finalproject.hrportal.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificationDTO {
    private Integer notificationId;
    private String recipientId;
    private String recipientType;
    private String senderId;
    private String senderType;
    private String notificationType;
    private String title;
    private String message;
    private Integer jobRequestId;
    private Integer projectId;
    private Integer applicationId;
    private Integer interviewId;
    private Integer candidateId;
    private String actionUrl;
    private Boolean isRead;
    private LocalDateTime readAt;
    private String priority;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
}


// Service Implementation
package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.repository.NotificationRepository;
import com.finalproject.hrportal.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;

    @Override
    @Transactional
    public void createNotification(NotificationDTO notificationDTO) {
        if (notificationDTO.getExpiresAt() == null) {
            notificationDTO.setExpiresAt(LocalDateTime.now().plusDays(30));
        }
        notificationRepository.createNotification(notificationDTO);
        log.info("Notification created for recipient: {}", notificationDTO.getRecipientId());
    }

    @Override
    @Transactional
    public void createJobRequestNotification(int jobRequestId, String type, String recipientId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setJobRequestId(jobRequestId);
        notification.setRecipientId(recipientId);
        notification.setNotificationType(type);
        
        switch (type) {
            case "JOB_REQUEST_CREATED":
                notification.setTitle("New Job Request");
                notification.setMessage("A new job request has been submitted for your review");
                notification.setRecipientType("PM");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/pm-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_APPROVED":
                notification.setTitle("Job Request Approved");
                notification.setMessage("Your job request has been approved by Project Manager");
                notification.setRecipientType("TL");
                notification.setPriority("HIGH");
                notification.setActionUrl("/tl-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_DECLINED":
                notification.setTitle("Job Request Declined");
                notification.setMessage("Your job request has been declined");
                notification.setRecipientType("TL");
                notification.setPriority("HIGH");
                notification.setActionUrl("/tl-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_FORWARDED":
                notification.setTitle("New Job Request from PM");
                notification.setMessage("A job request has been forwarded to you for posting");
                notification.setRecipientType("HR");
                notification.setPriority("HIGH");
                notification.setActionUrl("/hr-dashboard/job-requests");
                break;
                
            case "JOB_POSTED":
                notification.setTitle("Job Posted Successfully");
                notification.setMessage("The job request has been posted on the portal");
                notification.setRecipientType("TL");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/tl-dashboard/posted-jobs");
                break;
        }
        
        createNotification(notification);
    }

    @Override
    @Transactional
    public void createApplicationNotification(int applicationId, String type, String recipientId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setApplicationId(applicationId);
        notification.setRecipientId(recipientId);
        notification.setNotificationType(type);
        
        switch (type) {
            case "NEW_APPLICATION":
                notification.setTitle("New Candidate Application");
                notification.setMessage("A candidate has applied for one of your job postings");
                notification.setRecipientType("HR");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/hr-dashboard/candidates");
                break;
                
            case "APPLICATION_SHORTLISTED":
                notification.setTitle("Application Shortlisted");
                notification.setMessage("Congratulations! Your application has been shortlisted");
                notification.setRecipientType("CANDIDATE");
                notification.setPriority("HIGH");
                notification.setActionUrl("/candidate/applications");
                break;
                
            case "APPLICATION_REJECTED":
                notification.setTitle("Application Update");
                notification.setMessage("Thank you for your application. Unfortunately, we are moving forward with other candidates");
                notification.setRecipientType("CANDIDATE");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/candidate/applications");
                break;
        }
        
        createNotification(notification);
    }

    @Override
    @Transactional
    public void createInterviewNotification(int interviewId, String type, List<String> recipientIds) {
        for (String recipientId : recipientIds) {
            NotificationDTO notification = new NotificationDTO();
            notification.setInterviewId(interviewId);
            notification.setRecipientId(recipientId);
            notification.setNotificationType(type);
            
            switch (type) {
                case "INTERVIEW_SCHEDULED":
                    notification.setTitle("Interview Scheduled");
                    notification.setMessage("Your interview has been scheduled. Please check the details");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/interviews");
                    break;
                    
                case "INTERVIEW_REMINDER":
                    notification.setTitle("Interview Reminder");
                    notification.setMessage("You have an upcoming interview tomorrow");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/interviews");
                    break;
                    
                case "OFFER_LETTER_SENT":
                    notification.setTitle("Offer Letter Received");
                    notification.setMessage("Congratulations! You have received an offer letter");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/offers");
                    break;
            }
            
            createNotification(notification);
        }
    }

    @Override
    @Transactional
    public void createProjectAssignmentNotification(int projectId, String employeeId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setProjectId(projectId);
        notification.setRecipientId(employeeId);
        notification.setRecipientType("EMPLOYEE");
        notification.setNotificationType("PROJECT_ASSIGNED");
        notification.setTitle("Project Assigned");
        notification.setMessage("You have been assigned to a new project");
        notification.setPriority("HIGH");
        notification.setActionUrl("/employee/projects");
        
        createNotification(notification);
    }

    @Override
    public List<NotificationDTO> getUnreadNotifications(String recipientId) {
        return notificationRepository.getUnreadNotifications(recipientId);
    }

    @Override
    public List<NotificationDTO> getAllNotifications(String recipientId, int page, int size) {
        return notificationRepository.getAllNotifications(recipientId, page, size);
    }

    @Override
    public Integer getUnreadCount(String recipientId) {
        return notificationRepository.getUnreadCount(recipientId);
    }

    @Override
    @Transactional
    public boolean markAsRead(int notificationId) {
        return notificationRepository.markAsRead(notificationId);
    }

    @Override
    @Transactional
    public boolean markAllAsRead(String recipientId) {
        return notificationRepository.markAllAsRead(recipientId);
    }

    @Override
    @Transactional
    public boolean deleteNotification(int notificationId) {
        return notificationRepository.deleteNotification(notificationId);
    }

    @Override
    @Transactional
    public void cleanupExpiredNotifications() {
        int deleted = notificationRepository.deleteExpiredNotifications();
        log.info("Cleaned up {} expired notifications", deleted);
    }
}





package com.finalproject.hrportal.repository;

import com.finalproject.hrportal.dto.NotificationDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;

@Repository
@RequiredArgsConstructor
public class NotificationRepository {

    private final JdbcTemplate jdbcTemplate;

    private final RowMapper<NotificationDTO> notificationRowMapper = (rs, rowNum) -> {
        NotificationDTO dto = new NotificationDTO();
        dto.setNotificationId(rs.getInt("NOTIFICATION_ID"));
        dto.setRecipientId(rs.getString("RECIPIENT_ID"));
        dto.setRecipientType(rs.getString("RECIPIENT_TYPE"));
        dto.setSenderId(rs.getString("SENDER_ID"));
        dto.setSenderType(rs.getString("SENDER_TYPE"));
        dto.setNotificationType(rs.getString("NOTIFICATION_TYPE"));
        dto.setTitle(rs.getString("TITLE"));
        dto.setMessage(rs.getString("MESSAGE"));
        dto.setJobRequestId((Integer) rs.getObject("JOB_REQUEST_ID"));
        dto.setProjectId((Integer) rs.getObject("PROJECT_ID"));
        dto.setApplicationId((Integer) rs.getObject("APPLICATION_ID"));
        dto.setInterviewId((Integer) rs.getObject("INTERVIEW_ID"));
        dto.setCandidateId((Integer) rs.getObject("CANDIDATE_ID"));
        dto.setActionUrl(rs.getString("ACTION_URL"));
        dto.setIsRead(rs.getInt("IS_READ") == 1);
        
        Timestamp readAt = rs.getTimestamp("READ_AT");
        dto.setReadAt(readAt != null ? readAt.toLocalDateTime() : null);
        
        dto.setPriority(rs.getString("PRIORITY"));
        dto.setCreatedAt(rs.getTimestamp("CREATED_AT").toLocalDateTime());
        
        Timestamp expiresAt = rs.getTimestamp("EXPIRES_AT");
        dto.setExpiresAt(expiresAt != null ? expiresAt.toLocalDateTime() : null);
        
        return dto;
    };

    public void createNotification(NotificationDTO notification) {
        String sql = """
            INSERT INTO NOTIFICATIONS (
                NOTIFICATION_ID, RECIPIENT_ID, RECIPIENT_TYPE, SENDER_ID, SENDER_TYPE,
                NOTIFICATION_TYPE, TITLE, MESSAGE, JOB_REQUEST_ID, PROJECT_ID,
                APPLICATION_ID, INTERVIEW_ID, CANDIDATE_ID, ACTION_URL,
                IS_READ, PRIORITY, CREATED_AT, EXPIRES_AT
            ) VALUES (
                NOTIFICATION_SEQ.NEXTVAL, ?, ?, ?, ?,
                ?, ?, ?, ?, ?,
                ?, ?, ?, ?,
                0, ?, SYSDATE, ?
            )
        """;

        jdbcTemplate.update(sql,
            notification.getRecipientId(),
            notification.getRecipientType(),
            notification.getSenderId(),
            notification.getSenderType(),
            notification.getNotificationType(),
            notification.getTitle(),
            notification.getMessage(),
            notification.getJobRequestId(),
            notification.getProjectId(),
            notification.getApplicationId(),
            notification.getInterviewId(),
            notification.getCandidateId(),
            notification.getActionUrl(),
            notification.getPriority(),
            notification.getExpiresAt() != null ? Timestamp.valueOf(notification.getExpiresAt()) : null
        );
    }

    public List<NotificationDTO> getUnreadNotifications(String recipientId) {
        String sql = """
            SELECT * FROM NOTIFICATIONS
            WHERE RECIPIENT_ID = ? AND IS_READ = 0
            ORDER BY CREATED_AT DESC
        """;
        return jdbcTemplate.query(sql, notificationRowMapper, recipientId);
    }

    public List<NotificationDTO> getAllNotifications(String recipientId, int page, int size) {
        String sql = """
            SELECT * FROM (
                SELECT n.*, ROW_NUMBER() OVER (ORDER BY CREATED_AT DESC) as rn
                FROM NOTIFICATIONS n
                WHERE RECIPIENT_ID = ?
            ) WHERE rn BETWEEN ? AND ?
        """;
        int start = (page - 1) * size + 1;
        int end = page * size;
        return jdbcTemplate.query(sql, notificationRowMapper, recipientId, start, end);
    }

    public Integer getUnreadCount(String recipientId) {
        String sql = """
            SELECT COUNT(*) FROM NOTIFICATIONS
            WHERE RECIPIENT_ID = ? AND IS_READ = 0
        """;
        return jdbcTemplate.queryForObject(sql, Integer.class, recipientId);
    }

    public boolean markAsRead(int notificationId) {
        String sql = """
            UPDATE NOTIFICATIONS
            SET IS_READ = 1, READ_AT = SYSDATE
            WHERE NOTIFICATION_ID = ?
        """;
        return jdbcTemplate.update(sql, notificationId) > 0;
    }

    public boolean markAllAsRead(String recipientId) {
        String sql = """
            UPDATE NOTIFICATIONS
            SET IS_READ = 1, READ_AT = SYSDATE
            WHERE RECIPIENT_ID = ? AND IS_READ = 0
        """;
        return jdbcTemplate.update(sql, recipientId) > 0;
    }

    public boolean deleteNotification(int notificationId) {
        String sql = "DELETE FROM NOTIFICATIONS WHERE NOTIFICATION_ID = ?";
        return jdbcTemplate.update(sql, notificationId) > 0;
    }

    public int deleteExpiredNotifications() {
        String sql = """
            DELETE FROM NOTIFICATIONS
            WHERE EXPIRES_AT IS NOT NULL AND EXPIRES_AT < SYSDATE
        """;
        return jdbcTemplate.update(sql);
    }
}







package com.finalproject.hrportal.controller;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.service.NotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@CrossOrigin("*")
public class NotificationController {

    private final NotificationService notificationService;

    @GetMapping("/unread/{recipientId}")
    public ResponseEntity<List<NotificationDTO>> getUnreadNotifications(@PathVariable String recipientId) {
        return ResponseEntity.ok(notificationService.getUnreadNotifications(recipientId));
    }

    @GetMapping("/all/{recipientId}")
    public ResponseEntity<List<NotificationDTO>> getAllNotifications(
            @PathVariable String recipientId,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "20") int size) {
        return ResponseEntity.ok(notificationService.getAllNotifications(recipientId, page, size));
    }

    @GetMapping("/count/unread/{recipientId}")
    public ResponseEntity<Integer> getUnreadCount(@PathVariable String recipientId) {
        return ResponseEntity.ok(notificationService.getUnreadCount(recipientId));
    }

    @PatchMapping("/mark-read/{notificationId}")
    public ResponseEntity<String> markAsRead(@PathVariable int notificationId) {
        if (notificationService.markAsRead(notificationId)) {
            return ResponseEntity.ok("Notification marked as read");
        }
        return ResponseEntity.badRequest().body("Failed to mark notification as read");
    }

    @PatchMapping("/mark-all-read/{recipientId}")
    public ResponseEntity<String> markAllAsRead(@PathVariable String recipientId) {
        if (notificationService.markAllAsRead(recipientId)) {
            return ResponseEntity.ok("All notifications marked as read");
        }
        return ResponseEntity.badRequest().body("Failed to mark notifications as read");
    }

    @DeleteMapping("/{notificationId}")
    public ResponseEntity<String> deleteNotification(@PathVariable int notificationId) {
        if (notificationService.deleteNotification(notificationId)) {
            return ResponseEntity.ok("Notification deleted");
        }
        return ResponseEntity.badRequest().body("Failed to delete notification");
    }
}


// ============================================
// INTEGRATION: Update HrServiceImpl
// ============================================

package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.service.NotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class HrServiceImpl implements HrService {

    private final NotificationService notificationService;
    private final JobRequestRepository jobRequestRepository;
    private final CandidateApplicationRepository candidateApplicationRepository;
    // ... other dependencies

    @Override
    @Transactional
    public boolean postJobOnPortal(int jobRequestId) {
        boolean posted = jobRequestRepository.postJobOnPortal(jobRequestId);
        
        if (posted) {
            // Get the job request details to notify relevant parties
            PmJobRequestResponseDTO jobRequest = jobRequestRepository.getJobRequestById(jobRequestId);
            
            // Notify Team Leader that job is posted
            if (jobRequest.getTeamLeaderId() != null) {
                notificationService.createJobRequestNotification(
                    jobRequestId, 
                    "JOB_POSTED", 
                    jobRequest.getTeamLeaderId()
                );
            }
            
            // Notify Project Manager
            if (jobRequest.getProjectManagerId() != null) {
                notificationService.createJobRequestNotification(
                    jobRequestId, 
                    "JOB_POSTED", 
                    jobRequest.getProjectManagerId()
                );
            }
        }
        
        return posted;
    }

    @Override
    @Transactional
    public boolean changeStatusOfCandidateToShortListed(int applicationId, String status) {
        boolean updated = candidateApplicationRepository.changeStatusOfCandidateToShortListed(applicationId, status);
        
        if (updated) {
            // Get candidate details
            AppliedCandidatesDTO application = candidateApplicationRepository.getApplicationById(applicationId);
            
            String notificationType = status.equalsIgnoreCase("SHORTLISTED") 
                ? "APPLICATION_SHORTLISTED" 
                : "APPLICATION_REJECTED";
                
            // Notify candidate about status change
            notificationService.createApplicationNotification(
                applicationId,
                notificationType,
                String.valueOf(application.getCandidateId())
            );
        }
        
        return updated;
    }
}


// ============================================
// INTEGRATION: Update PmServiceImpl
// ============================================

package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.service.NotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class PmServiceImpl implements PmService {

    private final NotificationService notificationService;
    private final JobRequestRepository jobRequestRepository;
    // ... other dependencies

    @Override
    @Transactional
    public boolean setProjectIdToEmployee(int jobRequestId, int projectId, String employeeId) {
        int count = jobRequestRepository.updateHeadCount(jobRequestId);
        if (count > 0) {
            boolean assigned = projectRepository.setProjectIdToEmployee(projectId, employeeId);
            
            if (assigned) {
                // Notify employee about project assignment
                notificationService.createProjectAssignmentNotification(projectId, employeeId);
                
                // Close job request and notify team lead
                PmJobRequestResponseDTO jobRequest = jobRequestRepository.getJobRequestById(jobRequestId);
                if (jobRequest.getTeamLeaderId() != null) {
                    notificationService.createJobRequestNotification(
                        jobRequestId,
                        "EMPLOYEE_ASSIGNED",
                        jobRequest.getTeamLeaderId()
                    );
                }
            }
            
            return assigned;
        }
        return false;
    }

    @Override
    @Transactional
    public boolean forwardToHr(HrForwardDTO hrForwardDTO, int jobRequestId) {
        boolean forwarded = jobRequestRepository.forwardToHr(hrForwardDTO, jobRequestId);
        
        if (forwarded) {
            // Notify HR about the forwarded job request
            notificationService.createJobRequestNotification(
                jobRequestId,
                "JOB_REQUEST_FORWARDED",
                hrForwardDTO.getHrId()
            );
            
            // Notify Team Lead that request was forwarded
            PmJobRequestResponseDTO jobRequest = jobRequestRepository.getJobRequestById(jobRequestId);
            if (jobRequest.getTeamLeaderId() != null) {
                notificationService.createJobRequestNotification(
                    jobRequestId,
                    "JOB_REQUEST_FORWARDED",
                    jobRequest.getTeamLeaderId()
                );
            }
        }
        
        return forwarded;
    }

    @Override
    @Transactional
    public boolean declinedTheJobRequest(int jobRequestId) {
        boolean declined = jobRequestRepository.declinedTheJobRequest(jobRequestId);
        
        if (declined) {
            // Notify Team Lead about declined request
            PmJobRequestResponseDTO jobRequest = jobRequestRepository.getJobRequestById(jobRequestId);
            if (jobRequest.getTeamLeaderId() != null) {
                notificationService.createJobRequestNotification(
                    jobRequestId,
                    "JOB_REQUEST_DECLINED",
                    jobRequest.getTeamLeaderId()
                );
            }
        }
        
        return declined;
    }
}


//









===========================================================v2==========================================================================

// ============================================
// 1. Add WebSocket Dependency to pom.xml
// ============================================
/*
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
*/

// ============================================
// 2. WebSocket Configuration
// ============================================
package com.finalproject.hrportal.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Enable a simple memory-based message broker to send messages to clients
        config.enableSimpleBroker("/topic", "/queue");
        // Prefix for messages from clients
        config.setApplicationDestinationPrefixes("/app");
        // Prefix for user-specific messages
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // WebSocket endpoint that clients will connect to
        registry.addEndpoint("/ws-notifications")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
}


// ============================================
// 3. WebSocket Notification DTO
// ============================================
package com.finalproject.hrportal.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WebSocketNotificationDTO {
    private Integer notificationId;
    private String recipientId;
    private String recipientType;
    private String senderId;
    private String senderName;
    private String notificationType;
    private String title;
    private String message;
    private Integer jobRequestId;
    private Integer projectId;
    private Integer applicationId;
    private Integer interviewId;
    private String actionUrl;
    private String priority;
    private LocalDateTime timestamp;
    private String icon; // For UI display
    private String color; // For UI styling
}


// ============================================
// 4. WebSocket Notification Service
// ============================================
package com.finalproject.hrportal.service;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.dto.WebSocketNotificationDTO;

public interface WebSocketNotificationService {
    void sendNotificationToUser(String userId, WebSocketNotificationDTO notification);
    void sendNotificationToRole(String role, WebSocketNotificationDTO notification);
    void broadcastNotification(WebSocketNotificationDTO notification);
}


package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.dto.WebSocketNotificationDTO;
import com.finalproject.hrportal.service.WebSocketNotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class WebSocketNotificationServiceImpl implements WebSocketNotificationService {

    private final SimpMessagingTemplate messagingTemplate;

    @Override
    public void sendNotificationToUser(String userId, WebSocketNotificationDTO notification) {
        log.info("Sending WebSocket notification to user: {}", userId);
        // Send to specific user's queue
        messagingTemplate.convertAndSendToUser(
            userId, 
            "/queue/notifications", 
            notification
        );
    }

    @Override
    public void sendNotificationToRole(String role, WebSocketNotificationDTO notification) {
        log.info("Broadcasting notification to role: {}", role);
        // Broadcast to all users with specific role
        messagingTemplate.convertAndSend(
            "/topic/notifications/" + role.toLowerCase(), 
            notification
        );
    }

    @Override
    public void broadcastNotification(WebSocketNotificationDTO notification) {
        log.info("Broadcasting notification to all users");
        // Broadcast to all connected users
        messagingTemplate.convertAndSend(
            "/topic/notifications/all", 
            notification
        );
    }
}


// ============================================
// 5. Enhanced Notification Service with WebSocket
// ============================================
package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.dto.WebSocketNotificationDTO;
import com.finalproject.hrportal.repository.NotificationRepository;
import com.finalproject.hrportal.service.NotificationService;
import com.finalproject.hrportal.service.WebSocketNotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final WebSocketNotificationService webSocketService;

    @Override
    @Transactional
    public void createNotification(NotificationDTO notificationDTO) {
        if (notificationDTO.getExpiresAt() == null) {
            notificationDTO.setExpiresAt(LocalDateTime.now().plusDays(30));
        }
        
        // Save to database
        notificationRepository.createNotification(notificationDTO);
        
        // Send real-time WebSocket notification
        WebSocketNotificationDTO wsNotification = convertToWebSocketDTO(notificationDTO);
        webSocketService.sendNotificationToUser(notificationDTO.getRecipientId(), wsNotification);
        
        log.info("Notification created and sent via WebSocket to: {}", notificationDTO.getRecipientId());
    }

    @Override
    @Transactional
    public void createJobRequestNotification(int jobRequestId, String type, String recipientId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setJobRequestId(jobRequestId);
        notification.setRecipientId(recipientId);
        notification.setNotificationType(type);
        
        switch (type) {
            case "JOB_REQUEST_CREATED":
                notification.setTitle("New Job Request");
                notification.setMessage("A new job request has been submitted for your review");
                notification.setRecipientType("PM");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/pm-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_APPROVED":
                notification.setTitle("Job Request Approved");
                notification.setMessage("Your job request has been approved by Project Manager");
                notification.setRecipientType("TL");
                notification.setPriority("HIGH");
                notification.setActionUrl("/tl-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_DECLINED":
                notification.setTitle("Job Request Declined");
                notification.setMessage("Your job request has been declined");
                notification.setRecipientType("TL");
                notification.setPriority("HIGH");
                notification.setActionUrl("/tl-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_FORWARDED":
                notification.setTitle("New Job Request from PM");
                notification.setMessage("A job request has been forwarded to you for posting");
                notification.setRecipientType("HR");
                notification.setPriority("HIGH");
                notification.setActionUrl("/hr-dashboard/job-requests");
                break;
                
            case "JOB_POSTED":
                notification.setTitle("Job Posted Successfully");
                notification.setMessage("The job request has been posted on the portal");
                notification.setRecipientType("TL");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/tl-dashboard/posted-jobs");
                break;
        }
        
        createNotification(notification);
    }

    @Override
    @Transactional
    public void createApplicationNotification(int applicationId, String type, String recipientId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setApplicationId(applicationId);
        notification.setRecipientId(recipientId);
        notification.setNotificationType(type);
        
        switch (type) {
            case "NEW_APPLICATION":
                notification.setTitle("New Candidate Application");
                notification.setMessage("A candidate has applied for one of your job postings");
                notification.setRecipientType("HR");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/hr-dashboard/candidates");
                break;
                
            case "APPLICATION_SHORTLISTED":
                notification.setTitle("Application Shortlisted! 🎉");
                notification.setMessage("Congratulations! Your application has been shortlisted");
                notification.setRecipientType("CANDIDATE");
                notification.setPriority("HIGH");
                notification.setActionUrl("/candidate/applications");
                break;
                
            case "APPLICATION_REJECTED":
                notification.setTitle("Application Update");
                notification.setMessage("Thank you for your application. Unfortunately, we are moving forward with other candidates");
                notification.setRecipientType("CANDIDATE");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/candidate/applications");
                break;
        }
        
        createNotification(notification);
    }

    @Override
    @Transactional
    public void createInterviewNotification(int interviewId, String type, List<String> recipientIds) {
        for (String recipientId : recipientIds) {
            NotificationDTO notification = new NotificationDTO();
            notification.setInterviewId(interviewId);
            notification.setRecipientId(recipientId);
            notification.setNotificationType(type);
            
            switch (type) {
                case "INTERVIEW_SCHEDULED":
                    notification.setTitle("Interview Scheduled 📅");
                    notification.setMessage("Your interview has been scheduled. Please check the details");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/interviews");
                    break;
                    
                case "INTERVIEW_REMINDER":
                    notification.setTitle("Interview Reminder ⏰");
                    notification.setMessage("You have an upcoming interview tomorrow");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/interviews");
                    break;
                    
                case "OFFER_LETTER_SENT":
                    notification.setTitle("Offer Letter Received 🎊");
                    notification.setMessage("Congratulations! You have received an offer letter");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/offers");
                    break;
            }
            
            createNotification(notification);
        }
    }

    @Override
    @Transactional
    public void createProjectAssignmentNotification(int projectId, String employeeId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setProjectId(projectId);
        notification.setRecipientId(employeeId);
        notification.setRecipientType("EMPLOYEE");
        notification.setNotificationType("PROJECT_ASSIGNED");
        notification.setTitle("Project Assigned 🚀");
        notification.setMessage("You have been assigned to a new project");
        notification.setPriority("HIGH");
        notification.setActionUrl("/employee/projects");
        
        createNotification(notification);
    }

    private WebSocketNotificationDTO convertToWebSocketDTO(NotificationDTO dto) {
        return WebSocketNotificationDTO.builder()
            .notificationId(dto.getNotificationId())
            .recipientId(dto.getRecipientId())
            .recipientType(dto.getRecipientType())
            .senderId(dto.getSenderId())
            .notificationType(dto.getNotificationType())
            .title(dto.getTitle())
            .message(dto.getMessage())
            .jobRequestId(dto.getJobRequestId())
            .projectId(dto.getProjectId())
            .applicationId(dto.getApplicationId())
            .interviewId(dto.getInterviewId())
            .actionUrl(dto.getActionUrl())
            .priority(dto.getPriority())
            .timestamp(LocalDateTime.now())
            .icon(getIconForType(dto.getNotificationType()))
            .color(getColorForPriority(dto.getPriority()))
            .build();
    }

    private String getIconForType(String type) {
        return switch (type) {
            case "JOB_REQUEST_CREATED", "JOB_REQUEST_FORWARDED" -> "fas fa-clipboard-list";
            case "JOB_REQUEST_APPROVED" -> "fas fa-check-circle";
            case "JOB_REQUEST_DECLINED" -> "fas fa-times-circle";
            case "JOB_POSTED" -> "fas fa-bullhorn";
            case "NEW_APPLICATION" -> "fas fa-user-plus";
            case "APPLICATION_SHORTLISTED" -> "fas fa-star";
            case "APPLICATION_REJECTED" -> "fas fa-ban";
            case "INTERVIEW_SCHEDULED", "INTERVIEW_REMINDER" -> "fas fa-calendar-check";
            case "OFFER_LETTER_SENT" -> "fas fa-envelope";
            case "PROJECT_ASSIGNED" -> "fas fa-project-diagram";
            default -> "fas fa-bell";
        };
    }

    private String getColorForPriority(String priority) {
        return switch (priority) {
            case "HIGH" -> "#ef4444";
            case "MEDIUM" -> "#f59e0b";
            case "LOW" -> "#10b981";
            default -> "#6b7280";
        };
    }

    // Other methods remain same...
    @Override
    public List<NotificationDTO> getUnreadNotifications(String recipientId) {
        return notificationRepository.getUnreadNotifications(recipientId);
    }

    @Override
    public List<NotificationDTO> getAllNotifications(String recipientId, int page, int size) {
        return notificationRepository.getAllNotifications(recipientId, page, size);
    }

    @Override
    public Integer getUnreadCount(String recipientId) {
        return notificationRepository.getUnreadCount(recipientId);
    }

    @Override
    @Transactional
    public boolean markAsRead(int notificationId) {
        return notificationRepository.markAsRead(notificationId);
    }

    @Override
    @Transactional
    public boolean markAllAsRead(String recipientId) {
        return notificationRepository.markAllAsRead(recipientId);
    }

    @Override
    @Transactional
    public boolean deleteNotification(int notificationId) {
        return notificationRepository.deleteNotification(notificationId);
    }

    @Override
    @Transactional
    public void cleanupExpiredNotifications() {
        int deleted = notificationRepository.deleteExpiredNotifications();
        log.info("Cleaned up {} expired notifications", deleted);
    }
}


// ============================================
// 6. WebSocket Controller
// ============================================
package com.finalproject.hrportal.controller;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.service.NotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.annotation.SendToUser;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.security.Principal;
import java.util.List;

@Controller
@RequiredArgsConstructor
public class WebSocketNotificationController {

    private final NotificationService notificationService;

    // Handle client subscription to notifications
    @MessageMapping("/notifications/subscribe")
    @SendToUser("/queue/notifications")
    public List<NotificationDTO> subscribeToNotifications(Principal principal) {
        // When user connects, send their unread notifications
        String userId = principal.getName();
        return notificationService.getUnreadNotifications(userId);
    }

    // Mark notification as read via WebSocket
    @MessageMapping("/notifications/mark-read")
    public void markAsRead(@Payload Integer notificationId) {
        notificationService.markAsRead(notificationId);
    }
}


// REST Controller for HTTP endpoints
@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@CrossOrigin("*")
public class NotificationRestController {

    private final NotificationService notificationService;

    @GetMapping("/unread/{recipientId}")
    public ResponseEntity<List<NotificationDTO>> getUnreadNotifications(@PathVariable String recipientId) {
        return ResponseEntity.ok(notificationService.getUnreadNotifications(recipientId));
    }

    @GetMapping("/all/{recipientId}")
    public ResponseEntity<List<NotificationDTO>> getAllNotifications(
            @PathVariable String recipientId,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "20") int size) {
        return ResponseEntity.ok(notificationService.getAllNotifications(recipientId, page, size));
    }

    @GetMapping("/count/unread/{recipientId}")
    public ResponseEntity<Integer> getUnreadCount(@PathVariable String recipientId) {
        return ResponseEntity.ok(notificationService.getUnreadCount(recipientId));
    }

    @PatchMapping("/mark-read/{notificationId}")
    public ResponseEntity<String> markAsRead(@PathVariable int notificationId) {
        if (notificationService.markAsRead(notificationId)) {
            return ResponseEntity.ok("Notification marked as read");
        }
        return ResponseEntity.badRequest().body("Failed to mark notification as read");
    }

    @PatchMapping("/mark-all-read/{recipientId}")
    public ResponseEntity<String> markAllAsRead(@PathVariable String recipientId) {
        if (notificationService.markAllAsRead(recipientId)) {
            return ResponseEntity.ok("All notifications marked as read");
        }
        return ResponseEntity.badRequest().body("Failed to mark notifications as read");
    }

    @DeleteMapping("/{notificationId}")
    public ResponseEntity<String> deleteNotification(@PathVariable int notificationId) {
        if (notificationService.deleteNotification(notificationId)) {
            return ResponseEntity.ok("Notification deleted");
        }
        return ResponseEntity.badRequest().body("Failed to delete notification");
    }
}



// ============================================
// 1. Add WebSocket Dependency to pom.xml
// ============================================
/*
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
*/

// ============================================
// 2. WebSocket Configuration
// ============================================
package com.finalproject.hrportal.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Enable a simple memory-based message broker to send messages to clients
        config.enableSimpleBroker("/topic", "/queue");
        // Prefix for messages from clients
        config.setApplicationDestinationPrefixes("/app");
        // Prefix for user-specific messages
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // WebSocket endpoint that clients will connect to
        registry.addEndpoint("/ws-notifications")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
}


// ============================================
// 3. WebSocket Notification DTO
// ============================================
package com.finalproject.hrportal.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WebSocketNotificationDTO {
    private Integer notificationId;
    private String recipientId;
    private String recipientType;
    private String senderId;
    private String senderName;
    private String notificationType;
    private String title;
    private String message;
    private Integer jobRequestId;
    private Integer projectId;
    private Integer applicationId;
    private Integer interviewId;
    private String actionUrl;
    private String priority;
    private LocalDateTime timestamp;
    private String icon; // For UI display
    private String color; // For UI styling
}


// ============================================
// 4. WebSocket Notification Service
// ============================================
package com.finalproject.hrportal.service;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.dto.WebSocketNotificationDTO;

public interface WebSocketNotificationService {
    void sendNotificationToUser(String userId, WebSocketNotificationDTO notification);
    void sendNotificationToRole(String role, WebSocketNotificationDTO notification);
    void broadcastNotification(WebSocketNotificationDTO notification);
}


package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.dto.WebSocketNotificationDTO;
import com.finalproject.hrportal.service.WebSocketNotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class WebSocketNotificationServiceImpl implements WebSocketNotificationService {

    private final SimpMessagingTemplate messagingTemplate;

    @Override
    public void sendNotificationToUser(String userId, WebSocketNotificationDTO notification) {
        log.info("Sending WebSocket notification to user: {}", userId);
        // Send to specific user's queue
        messagingTemplate.convertAndSendToUser(
            userId, 
            "/queue/notifications", 
            notification
        );
    }

    @Override
    public void sendNotificationToRole(String role, WebSocketNotificationDTO notification) {
        log.info("Broadcasting notification to role: {}", role);
        // Broadcast to all users with specific role
        messagingTemplate.convertAndSend(
            "/topic/notifications/" + role.toLowerCase(), 
            notification
        );
    }

    @Override
    public void broadcastNotification(WebSocketNotificationDTO notification) {
        log.info("Broadcasting notification to all users");
        // Broadcast to all connected users
        messagingTemplate.convertAndSend(
            "/topic/notifications/all", 
            notification
        );
    }
}


// ============================================
// 5. Enhanced Notification Service with WebSocket
// ============================================
package com.finalproject.hrportal.service.impl;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.dto.WebSocketNotificationDTO;
import com.finalproject.hrportal.repository.NotificationRepository;
import com.finalproject.hrportal.service.NotificationService;
import com.finalproject.hrportal.service.WebSocketNotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final WebSocketNotificationService webSocketService;

    @Override
    @Transactional
    public void createNotification(NotificationDTO notificationDTO) {
        if (notificationDTO.getExpiresAt() == null) {
            notificationDTO.setExpiresAt(LocalDateTime.now().plusDays(30));
        }
        
        // Save to database
        notificationRepository.createNotification(notificationDTO);
        
        // Send real-time WebSocket notification
        WebSocketNotificationDTO wsNotification = convertToWebSocketDTO(notificationDTO);
        webSocketService.sendNotificationToUser(notificationDTO.getRecipientId(), wsNotification);
        
        log.info("Notification created and sent via WebSocket to: {}", notificationDTO.getRecipientId());
    }

    @Override
    @Transactional
    public void createJobRequestNotification(int jobRequestId, String type, String recipientId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setJobRequestId(jobRequestId);
        notification.setRecipientId(recipientId);
        notification.setNotificationType(type);
        
        switch (type) {
            case "JOB_REQUEST_CREATED":
                notification.setTitle("New Job Request");
                notification.setMessage("A new job request has been submitted for your review");
                notification.setRecipientType("PM");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/pm-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_APPROVED":
                notification.setTitle("Job Request Approved");
                notification.setMessage("Your job request has been approved by Project Manager");
                notification.setRecipientType("TL");
                notification.setPriority("HIGH");
                notification.setActionUrl("/tl-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_DECLINED":
                notification.setTitle("Job Request Declined");
                notification.setMessage("Your job request has been declined");
                notification.setRecipientType("TL");
                notification.setPriority("HIGH");
                notification.setActionUrl("/tl-dashboard/job-requests");
                break;
                
            case "JOB_REQUEST_FORWARDED":
                notification.setTitle("New Job Request from PM");
                notification.setMessage("A job request has been forwarded to you for posting");
                notification.setRecipientType("HR");
                notification.setPriority("HIGH");
                notification.setActionUrl("/hr-dashboard/job-requests");
                break;
                
            case "JOB_POSTED":
                notification.setTitle("Job Posted Successfully");
                notification.setMessage("The job request has been posted on the portal");
                notification.setRecipientType("TL");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/tl-dashboard/posted-jobs");
                break;
        }
        
        createNotification(notification);
    }

    @Override
    @Transactional
    public void createApplicationNotification(int applicationId, String type, String recipientId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setApplicationId(applicationId);
        notification.setRecipientId(recipientId);
        notification.setNotificationType(type);
        
        switch (type) {
            case "NEW_APPLICATION":
                notification.setTitle("New Candidate Application");
                notification.setMessage("A candidate has applied for one of your job postings");
                notification.setRecipientType("HR");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/hr-dashboard/candidates");
                break;
                
            case "APPLICATION_SHORTLISTED":
                notification.setTitle("Application Shortlisted! 🎉");
                notification.setMessage("Congratulations! Your application has been shortlisted");
                notification.setRecipientType("CANDIDATE");
                notification.setPriority("HIGH");
                notification.setActionUrl("/candidate/applications");
                break;
                
            case "APPLICATION_REJECTED":
                notification.setTitle("Application Update");
                notification.setMessage("Thank you for your application. Unfortunately, we are moving forward with other candidates");
                notification.setRecipientType("CANDIDATE");
                notification.setPriority("MEDIUM");
                notification.setActionUrl("/candidate/applications");
                break;
        }
        
        createNotification(notification);
    }

    @Override
    @Transactional
    public void createInterviewNotification(int interviewId, String type, List<String> recipientIds) {
        for (String recipientId : recipientIds) {
            NotificationDTO notification = new NotificationDTO();
            notification.setInterviewId(interviewId);
            notification.setRecipientId(recipientId);
            notification.setNotificationType(type);
            
            switch (type) {
                case "INTERVIEW_SCHEDULED":
                    notification.setTitle("Interview Scheduled 📅");
                    notification.setMessage("Your interview has been scheduled. Please check the details");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/interviews");
                    break;
                    
                case "INTERVIEW_REMINDER":
                    notification.setTitle("Interview Reminder ⏰");
                    notification.setMessage("You have an upcoming interview tomorrow");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/interviews");
                    break;
                    
                case "OFFER_LETTER_SENT":
                    notification.setTitle("Offer Letter Received 🎊");
                    notification.setMessage("Congratulations! You have received an offer letter");
                    notification.setRecipientType("CANDIDATE");
                    notification.setPriority("HIGH");
                    notification.setActionUrl("/candidate/offers");
                    break;
            }
            
            createNotification(notification);
        }
    }

    @Override
    @Transactional
    public void createProjectAssignmentNotification(int projectId, String employeeId) {
        NotificationDTO notification = new NotificationDTO();
        notification.setProjectId(projectId);
        notification.setRecipientId(employeeId);
        notification.setRecipientType("EMPLOYEE");
        notification.setNotificationType("PROJECT_ASSIGNED");
        notification.setTitle("Project Assigned 🚀");
        notification.setMessage("You have been assigned to a new project");
        notification.setPriority("HIGH");
        notification.setActionUrl("/employee/projects");
        
        createNotification(notification);
    }

    private WebSocketNotificationDTO convertToWebSocketDTO(NotificationDTO dto) {
        return WebSocketNotificationDTO.builder()
            .notificationId(dto.getNotificationId())
            .recipientId(dto.getRecipientId())
            .recipientType(dto.getRecipientType())
            .senderId(dto.getSenderId())
            .notificationType(dto.getNotificationType())
            .title(dto.getTitle())
            .message(dto.getMessage())
            .jobRequestId(dto.getJobRequestId())
            .projectId(dto.getProjectId())
            .applicationId(dto.getApplicationId())
            .interviewId(dto.getInterviewId())
            .actionUrl(dto.getActionUrl())
            .priority(dto.getPriority())
            .timestamp(LocalDateTime.now())
            .icon(getIconForType(dto.getNotificationType()))
            .color(getColorForPriority(dto.getPriority()))
            .build();
    }

    private String getIconForType(String type) {
        return switch (type) {
            case "JOB_REQUEST_CREATED", "JOB_REQUEST_FORWARDED" -> "fas fa-clipboard-list";
            case "JOB_REQUEST_APPROVED" -> "fas fa-check-circle";
            case "JOB_REQUEST_DECLINED" -> "fas fa-times-circle";
            case "JOB_POSTED" -> "fas fa-bullhorn";
            case "NEW_APPLICATION" -> "fas fa-user-plus";
            case "APPLICATION_SHORTLISTED" -> "fas fa-star";
            case "APPLICATION_REJECTED" -> "fas fa-ban";
            case "INTERVIEW_SCHEDULED", "INTERVIEW_REMINDER" -> "fas fa-calendar-check";
            case "OFFER_LETTER_SENT" -> "fas fa-envelope";
            case "PROJECT_ASSIGNED" -> "fas fa-project-diagram";
            default -> "fas fa-bell";
        };
    }

    private String getColorForPriority(String priority) {
        return switch (priority) {
            case "HIGH" -> "#ef4444";
            case "MEDIUM" -> "#f59e0b";
            case "LOW" -> "#10b981";
            default -> "#6b7280";
        };
    }

    // Other methods remain same...
    @Override
    public List<NotificationDTO> getUnreadNotifications(String recipientId) {
        return notificationRepository.getUnreadNotifications(recipientId);
    }

    @Override
    public List<NotificationDTO> getAllNotifications(String recipientId, int page, int size) {
        return notificationRepository.getAllNotifications(recipientId, page, size);
    }

    @Override
    public Integer getUnreadCount(String recipientId) {
        return notificationRepository.getUnreadCount(recipientId);
    }

    @Override
    @Transactional
    public boolean markAsRead(int notificationId) {
        return notificationRepository.markAsRead(notificationId);
    }

    @Override
    @Transactional
    public boolean markAllAsRead(String recipientId) {
        return notificationRepository.markAllAsRead(recipientId);
    }

    @Override
    @Transactional
    public boolean deleteNotification(int notificationId) {
        return notificationRepository.deleteNotification(notificationId);
    }

    @Override
    @Transactional
    public void cleanupExpiredNotifications() {
        int deleted = notificationRepository.deleteExpiredNotifications();
        log.info("Cleaned up {} expired notifications", deleted);
    }
}


// ============================================
// 6. WebSocket Controller
// ============================================
package com.finalproject.hrportal.controller;

import com.finalproject.hrportal.dto.NotificationDTO;
import com.finalproject.hrportal.service.NotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.annotation.SendToUser;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.security.Principal;
import java.util.List;

@Controller
@RequiredArgsConstructor
public class WebSocketNotificationController {

    private final NotificationService notificationService;

    // Handle client subscription to notifications
    @MessageMapping("/notifications/subscribe")
    @SendToUser("/queue/notifications")
    public List<NotificationDTO> subscribeToNotifications(Principal principal) {
        // When user connects, send their unread notifications
        String userId = principal.getName();
        return notificationService.getUnreadNotifications(userId);
    }

    // Mark notification as read via WebSocket
    @MessageMapping("/notifications/mark-read")
    public void markAsRead(@Payload Integer notificationId) {
        notificationService.markAsRead(notificationId);
    }
}


// REST Controller for HTTP endpoints
@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@CrossOrigin("*")
public class NotificationRestController {

    private final NotificationService notificationService;

    @GetMapping("/unread/{recipientId}")
    public ResponseEntity<List<NotificationDTO>> getUnreadNotifications(@PathVariable String recipientId) {
        return ResponseEntity.ok(notificationService.getUnreadNotifications(recipientId));
    }

    @GetMapping("/all/{recipientId}")
    public ResponseEntity<List<NotificationDTO>> getAllNotifications(
            @PathVariable String recipientId,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "20") int size) {
        return ResponseEntity.ok(notificationService.getAllNotifications(recipientId, page, size));
    }

    @GetMapping("/count/unread/{recipientId}")
    public ResponseEntity<Integer> getUnreadCount(@PathVariable String recipientId) {
        return ResponseEntity.ok(notificationService.getUnreadCount(recipientId));
    }

    @PatchMapping("/mark-read/{notificationId}")
    public ResponseEntity<String> markAsRead(@PathVariable int notificationId) {
        if (notificationService.markAsRead(notificationId)) {
            return ResponseEntity.ok("Notification marked as read");
        }
        return ResponseEntity.badRequest().body("Failed to mark notification as read");
    }

    @PatchMapping("/mark-all-read/{recipientId}")
    public ResponseEntity<String> markAllAsRead(@PathVariable String recipientId) {
        if (notificationService.markAllAsRead(recipientId)) {
            return ResponseEntity.ok("All notifications marked as read");
        }
        return ResponseEntity.badRequest().body("Failed to mark notifications as read");
    }

    @DeleteMapping("/{notificationId}")
    public ResponseEntity<String> deleteNotification(@PathVariable int notificationId) {
        if (notificationService.deleteNotification(notificationId)) {
            return ResponseEntity.ok("Notification deleted");
        }
        return ResponseEntity.badRequest().body("Failed to delete notification");
    }
}




// ============================================
// 1. Install Dependencies
// ============================================
// npm install sockjs-client @stomp/stompjs rxjs


// ============================================
// 2. Notification Model
// ============================================
// notification.model.ts
export interface Notification {
  notificationId?: number;
  recipientId: string;
  recipientType: string;
  senderId?: string;
  senderName?: string;
  notificationType: string;
  title: string;
  message: string;
  jobRequestId?: number;
  projectId?: number;
  applicationId?: number;
  interviewId?: number;
  actionUrl?: string;
  priority: string;
  timestamp: Date;
  icon?: string;
  color?: string;
  isRead?: boolean;
}


// ============================================
// 3. WebSocket Notification Service
// ============================================
// websocket-notification.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import * as SockJS from 'sockjs-client';
import { Client, IFrame, IMessage } from '@stomp/stompjs';
import { Notification } from '../models/notification.model';

@Injectable({
  providedIn: 'root'
})
export class WebSocketNotificationService {
  private stompClient: Client | null = null;
  private notificationsSubject = new BehaviorSubject<Notification[]>([]);
  private unreadCountSubject = new BehaviorSubject<number>(0);
  private connected = false;

  public notifications$ = this.notificationsSubject.asObservable();
  public unreadCount$ = this.unreadCountSubject.asObservable();

  constructor() {}

  connect(userId: string): void {
    if (this.connected) {
      console.log('WebSocket already connected');
      return;
    }

    const socket = new SockJS('http://localhost:8080/ws-notifications');
    
    this.stompClient = new Client({
      webSocketFactory: () => socket as any,
      debug: (str) => {
        console.log('STOMP: ' + str);
      },
      reconnectDelay: 5000,
      heartbeatIncoming: 4000,
      heartbeatOutgoing: 4000
    });

    this.stompClient.onConnect = (frame: IFrame) => {
      console.log('Connected to WebSocket: ' + frame);
      this.connected = true;

      // Subscribe to user-specific notifications
      this.stompClient?.subscribe(
        `/user/${userId}/queue/notifications`,
        (message: IMessage) => {
          this.handleNotification(JSON.parse(message.body));
        }
      );

      // Subscribe to role-based notifications (optional)
      const userRole = this.getUserRole(); // Get from auth service
      if (userRole) {
        this.stompClient?.subscribe(
          `/topic/notifications/${userRole.toLowerCase()}`,
          (message: IMessage) => {
            this.handleNotification(JSON.parse(message.body));
          }
        );
      }

      // Request initial unread notifications
      this.loadUnreadNotifications(userId);
    };

    this.stompClient.onStompError = (frame: IFrame) => {
      console.error('WebSocket error: ' + frame.headers['message']);
      console.error('Additional details: ' + frame.body);
      this.connected = false;
    };

    this.stompClient.onWebSocketClose = () => {
      console.log('WebSocket connection closed');
      this.connected = false;
    };

    this.stompClient.activate();
  }

  disconnect(): void {
    if (this.stompClient && this.connected) {
      this.stompClient.deactivate();
      this.connected = false;
      console.log('Disconnected from WebSocket');
    }
  }

  private handleNotification(notification: Notification): void {
    // Add to notifications list
    const currentNotifications = this.notificationsSubject.value;
    this.notificationsSubject.next([notification, ...currentNotifications]);

    // Update unread count
    this.unreadCountSubject.next(this.unreadCountSubject.value + 1);

    // Show browser notification if permitted
    this.showBrowserNotification(notification);

    // Play notification sound
    this.playNotificationSound();
  }

  private loadUnreadNotifications(userId: string): void {
    // Call REST API to get initial unread notifications
    fetch(`http://localhost:8080/api/notifications/unread/${userId}`)
      .then(response => response.json())
      .then((notifications: Notification[]) => {
        this.notificationsSubject.next(notifications);
        this.unreadCountSubject.next(notifications.length);
      })
      .catch(error => console.error('Error loading notifications:', error));
  }

  markAsRead(notificationId: number): void {
    if (this.stompClient && this.connected) {
      this.stompClient.publish({
        destination: '/app/notifications/mark-read',
        body: JSON.stringify(notificationId)
      });

      // Update local state
      const notifications = this.notificationsSubject.value;
      const updated = notifications.map(n => 
        n.notificationId === notificationId ? { ...n, isRead: true } : n
      );
      this.notificationsSubject.next(updated);
      
      // Update unread count
      const unreadCount = updated.filter(n => !n.isRead).length;
      this.unreadCountSubject.next(unreadCount);
    }
  }

  markAllAsRead(userId: string): void {
    fetch(`http://localhost:8080/api/notifications/mark-all-read/${userId}`, {
      method: 'PATCH'
    })
      .then(() => {
        const notifications = this.notificationsSubject.value.map(n => ({
          ...n,
          isRead: true
        }));
        this.notificationsSubject.next(notifications);
        this.unreadCountSubject.next(0);
      })
      .catch(error => console.error('Error marking all as read:', error));
  }

  private showBrowserNotification(notification: Notification): void {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(notification.title, {
        body: notification.message,
        icon: '/assets/logo.png',
        badge: '/assets/badge.png',
        tag: `notification-${notification.notificationId}`,
        requireInteraction: notification.priority === 'HIGH'
      });
    }
  }

  private playNotificationSound(): void {
    const audio = new Audio('/assets/sounds/notification.mp3');
    audio.volume = 0.3;
    audio.play().catch(e => console.log('Could not play sound:', e));
  }

  requestNotificationPermission(): void {
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  }

  private getUserRole(): string | null {
    // Get from your auth service or local storage
    return localStorage.getItem('userRole');
  }

  isConnected(): boolean {
    return this.connected;
  }
}


// ============================================
// 4. Notification Component (TypeScript)
// ============================================
// notification.component.ts
import { Component, OnInit, OnDestroy } from '@angular/core';
import { WebSocketNotificationService } from '../../services/websocket-notification.service';
import { Notification } from '../../models/notification.model';
import { Router } from '@angular/router';

@Component({
  selector: 'app-notifications',
  templateUrl: './notification.component.html',
  styleUrls: ['./notification.component.css']
})
export class NotificationComponent implements OnInit, OnDestroy {
  notifications: Notification[] = [];
  unreadCount: number = 0;
  showDropdown: boolean = false;
  userId: string = '';

  constructor(
    private wsNotificationService: WebSocketNotificationService,
    private router: Router
  ) {}

  ngOnInit(): void {
    // Get user ID from your auth service
    this.userId = localStorage.getItem('userId') || '';

    // Request notification permission
    this.wsNotificationService.requestNotificationPermission();

    // Connect to WebSocket
    this.wsNotificationService.connect(this.userId);

    // Subscribe to notifications
    this.wsNotificationService.notifications$.subscribe(
      notifications => {
        this.notifications = notifications.slice(0, 10); // Show latest 10
      }
    );

    // Subscribe to unread count
    this.wsNotificationService.unreadCount$.subscribe(
      count => {
        this.unreadCount = count;
      }
    );
  }

  ngOnDestroy(): void {
    this.wsNotificationService.disconnect();
  }

  toggleDropdown(): void {
    this.showDropdown = !this.showDropdown;
  }

  markAsRead(notification: Notification): void {
    if (notification.notificationId && !notification.isRead) {
      this.wsNotificationService.markAsRead(notification.notificationId);
    }

    // Navigate to action URL
    if (notification.actionUrl) {
      this.router.navigate([notification.actionUrl]);
      this.showDropdown = false;
    }
  }

  markAllAsRead(): void {
    this.wsNotificationService.markAllAsRead(this.userId);
  }

  viewAllNotifications(): void {
    this.router.navigate(['/notifications']);
    this.showDropdown = false;
  }

  getTimeAgo(timestamp: Date): string {
    const now = new Date();
    const notifTime = new Date(timestamp);
    const diff = Math.floor((now.getTime() - notifTime.getTime()) / 1000);

    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    if (diff < 604800) return `${Math.floor(diff / 86400)}d ago`;
    return notifTime.toLocaleDateString();
  }
}



